{"version":3,"sources":["webpack://ts-test/webpack/universalModuleDefinition","webpack://ts-test/webpack/bootstrap","webpack://ts-test/../cross-domain-utils/dist/module/constants.js","webpack://ts-test/../cross-domain-utils/dist/module/utils.js","webpack://ts-test/../cross-domain-safe-weakmap/src/util.ts","webpack://ts-test/../cross-domain-safe-weakmap/src/weakmap.ts","webpack://ts-test/../belter/src/util.ts","webpack://ts-test/../cross-domain-safe-weakmap/src/native.ts","webpack://ts-test/./src/index.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","hasOwnProperty","p","s","IE_WIN_ACCESS_ERROR","isAboutProtocol","win","window","location","protocol","canReadFromWindow","err","getActualDomain","Error","PROTOCOL","parent","getParent","host","getDomain","domain","mockDomain","indexOf","iframeWindows","iframeFrames","isWindowClosed","allowMock","closed","message","desc","getOwnPropertyDescriptor","isActuallySameDomain","isSameDomain","mockclosed","top","iframeIndex","collection","item","length","safeIndexOf","frame","contentWindow","parentNode","doc","ownerDocument","documentElement","contains","isFrameWindowClosed","isWindow","obj","toString","Window","__cross_domain_utils_window_check__","objectIDs","CrossDomainSafeWeakMap","weakmap","keys","values","Math","random","WeakMap","freeze","testWeakMap","testKey","set","hasNativeWeakMap","_cleanupClosedWindows","delete","splice","isSafeToReadWrite","entry","writable","index","push","has","undefined","getOrSet","base64encode","str","btoa","encodeURIComponent","replace","p1","String","fromCharCode","parseInt","Buffer","from","uniqueID","chars","charAt","floor","Date","toISOString","slice","toLowerCase","serializeArgs","args","JSON","stringify","Array","subkey","val","uid","getObjectID","getEmptyObject","memoizeGlobalIndex","memoizeGlobalIndexValidFrom","memoize","method","options","simpleCache","thisCache","thisNamespace","cacheTime","time","memoizeIndex","fn","memoizedFunction","cache","cacheKey","cacheResult","now","apply","arguments","reset","__name__","displayName","setFunctionName","getUniqueID","stringToBase64","clear","result"],"mappings":"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","file":"ts-test.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"ts-test\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"ts-test\"] = factory();\n\telse\n\t\troot[\"ts-test\"] = factory();\n})((typeof self !== 'undefined' ? self : this), function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export var PROTOCOL = {\n  MOCK: 'mock:',\n  FILE: 'file:',\n  ABOUT: 'about:'\n};\nexport var WILDCARD = '*';\nexport var WINDOW_TYPE = {\n  IFRAME: 'iframe',\n  POPUP: 'popup'\n};","/* eslint max-lines: 0 */\nimport { isRegex, noop } from './util';\nimport { PROTOCOL, WILDCARD } from './constants';\nvar IE_WIN_ACCESS_ERROR = 'Call was rejected by callee.\\r\\n';\nexport function isFileProtocol(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return win.location.protocol === PROTOCOL.FILE;\n}\nexport function isAboutProtocol(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return win.location.protocol === PROTOCOL.ABOUT;\n}\nexport function getParent(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  if (!win) {\n    return;\n  }\n\n  try {\n    if (win.parent && win.parent !== win) {\n      return win.parent;\n    }\n  } catch (err) {// pass\n  }\n}\nexport function getOpener(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  if (!win) {\n    return;\n  } // Make sure we're not actually an iframe which has had window.open() called on us\n\n\n  if (getParent(win)) {\n    return;\n  }\n\n  try {\n    return win.opener;\n  } catch (err) {// pass\n  }\n}\nexport function canReadFromWindow(win) {\n  try {\n    noop(win && win.location && win.location.href);\n    return true;\n  } catch (err) {// pass\n  }\n\n  return false;\n}\nexport function getActualDomain(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var location = win.location;\n\n  if (!location) {\n    throw new Error(\"Can not read window location\");\n  }\n\n  var protocol = location.protocol;\n\n  if (!protocol) {\n    throw new Error(\"Can not read window protocol\");\n  }\n\n  if (protocol === PROTOCOL.FILE) {\n    return PROTOCOL.FILE + \"//\";\n  }\n\n  if (protocol === PROTOCOL.ABOUT) {\n    // @ts-ignore - trying to reassing to something that might be window\n    var parent = getParent(win);\n\n    if (parent && canReadFromWindow(parent)) {\n      // @ts-ignore\n      return getActualDomain(parent);\n    }\n\n    return PROTOCOL.ABOUT + \"//\";\n  }\n\n  var host = location.host;\n\n  if (!host) {\n    throw new Error(\"Can not read window host\");\n  }\n\n  return protocol + \"//\" + host;\n} // @ts-ignore\n\nexport function getDomain(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var domain = getActualDomain(win); // @ts-ignore - mockDomain\n\n  if (domain && win.mockDomain && win.mockDomain.indexOf(PROTOCOL.MOCK) === 0) {\n    // @ts-ignore - mockDomain\n    return win.mockDomain;\n  }\n\n  return domain;\n}\nexport function isBlankDomain(win) {\n  try {\n    if (!win.location.href) {\n      return true;\n    }\n\n    if (win.location.href === 'about:blank') {\n      return true;\n    }\n  } catch (err) {// pass\n  }\n\n  return false;\n}\nexport function isActuallySameDomain(win) {\n  try {\n    if (win === window) {\n      return true;\n    }\n  } catch (err) {// pass\n  }\n\n  try {\n    var desc = Object.getOwnPropertyDescriptor(win, 'location');\n\n    if (desc && desc.enumerable === false) {\n      return false;\n    }\n  } catch (err) {// pass\n  }\n\n  try {\n    if (isAboutProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n  } catch (err) {// pass\n  }\n\n  try {\n    if (getActualDomain(win) === getActualDomain(window)) {\n      return true;\n    }\n  } catch (err) {// pass\n  }\n\n  return false;\n}\nexport function isSameDomain(win) {\n  // @ts-ignore\n  if (!isActuallySameDomain(win)) {\n    return false;\n  }\n\n  try {\n    if (win === window) {\n      return true;\n    }\n\n    if (isAboutProtocol(win) && canReadFromWindow(win)) {\n      return true;\n    }\n\n    if (getDomain(window) === getDomain(win)) {\n      return true;\n    }\n  } catch (err) {// pass\n  }\n\n  return false;\n}\nexport function assertSameDomain(win) {\n  if (!isSameDomain(win)) {\n    throw new Error(\"Expected window to be same domain\");\n  }\n\n  return win;\n}\nexport function getParents(win) {\n  var result = [];\n\n  try {\n    while (win.parent !== win) {\n      result.push(win.parent);\n      win = win.parent;\n    }\n  } catch (err) {// pass\n  }\n\n  return result;\n}\nexport function isAncestorParent(parent, child) {\n  if (!parent || !child) {\n    return false;\n  }\n\n  var childParent = getParent(child);\n\n  if (childParent) {\n    return childParent === parent;\n  }\n\n  if (getParents(child).indexOf(parent) !== -1) {\n    return true;\n  }\n\n  return false;\n}\nexport function getFrames(win) {\n  var result = [];\n  var frames;\n\n  try {\n    frames = win.frames;\n  } catch (err) {\n    frames = win;\n  }\n\n  var len;\n\n  try {\n    len = frames.length;\n  } catch (err) {// pass\n  }\n\n  if (len === 0) {\n    return result;\n  }\n\n  if (len) {\n    for (var i = 0; i < len; i++) {\n      var frame = void 0;\n\n      try {\n        frame = frames[i];\n      } catch (err) {\n        continue;\n      }\n\n      result.push(frame);\n    }\n\n    return result;\n  }\n\n  for (var _i = 0; _i < 100; _i++) {\n    var _frame = void 0;\n\n    try {\n      _frame = frames[_i];\n    } catch (err) {\n      return result;\n    }\n\n    if (!_frame) {\n      return result;\n    }\n\n    result.push(_frame);\n  }\n\n  return result;\n}\nexport function getAllChildFrames(win) {\n  var result = [];\n\n  for (var _i3 = 0, _getFrames2 = getFrames(win); _i3 < _getFrames2.length; _i3++) {\n    var frame = _getFrames2[_i3];\n    result.push(frame);\n\n    for (var _i5 = 0, _getAllChildFrames2 = getAllChildFrames(frame); _i5 < _getAllChildFrames2.length; _i5++) {\n      var childFrame = _getAllChildFrames2[_i5];\n      result.push(childFrame);\n    }\n  }\n\n  return result;\n}\nexport function getTop(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  try {\n    if (win.top) {\n      return win.top;\n    }\n  } catch (err) {// pass\n  }\n\n  if (getParent(win) === win) {\n    return win;\n  }\n\n  try {\n    if (isAncestorParent(window, win) && window.top) {\n      return window.top;\n    }\n  } catch (err) {// pass\n  }\n\n  try {\n    if (isAncestorParent(win, window) && window.top) {\n      return window.top;\n    }\n  } catch (err) {// pass\n  }\n\n  for (var _i7 = 0, _getAllChildFrames4 = getAllChildFrames(win); _i7 < _getAllChildFrames4.length; _i7++) {\n    var frame = _getAllChildFrames4[_i7];\n\n    try {\n      if (frame.top) {\n        return frame.top;\n      }\n    } catch (err) {// pass\n    }\n\n    if (getParent(frame) === frame) {\n      return frame;\n    }\n  }\n}\nexport function getNextOpener(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return getOpener(getTop(win) || win);\n}\nexport function getUltimateTop(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var opener = getNextOpener(win);\n\n  if (opener) {\n    return getUltimateTop(opener);\n  }\n\n  return top;\n}\nexport function getAllFramesInWindow(win) {\n  var top = getTop(win);\n\n  if (!top) {\n    throw new Error(\"Can not determine top window\");\n  }\n\n  var result = [].concat(getAllChildFrames(top), [top]); // Win may be in shadow dom\n\n  if (result.indexOf(win) === -1) {\n    result = [].concat(result, [win], getAllChildFrames(win));\n  }\n\n  return result;\n}\nexport function getAllWindows(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var frames = getAllFramesInWindow(win);\n  var opener = getNextOpener(win);\n\n  if (opener) {\n    return [].concat(getAllWindows(opener), frames);\n  } else {\n    return frames;\n  }\n}\nexport function isTop(win) {\n  return win === getTop(win);\n}\nexport function isFrameWindowClosed(frame) {\n  if (!frame.contentWindow) {\n    return true;\n  }\n\n  if (!frame.parentNode) {\n    return true;\n  }\n\n  var doc = frame.ownerDocument;\n\n  if (doc && doc.documentElement && !doc.documentElement.contains(frame)) {\n    var parent = frame;\n\n    while (parent.parentNode && parent.parentNode !== parent) {\n      // @ts-ignore\n      parent = parent.parentNode;\n    } // @ts-ignore\n\n\n    if (!parent.host || !doc.documentElement.contains(parent.host)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction safeIndexOf(collection, item) {\n  for (var i = 0; i < collection.length; i++) {\n    try {\n      if (collection[i] === item) {\n        return i;\n      }\n    } catch (err) {// pass\n    }\n  }\n\n  return -1;\n}\n\nvar iframeWindows = [];\nvar iframeFrames = [];\nexport function isWindowClosed(win, allowMock) {\n  if (allowMock === void 0) {\n    allowMock = true;\n  }\n\n  try {\n    if (win === window) {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (!win) {\n      return true;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (win.closed) {\n      return true;\n    }\n  } catch (err) {\n    // I love you so much IE\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return false;\n    }\n\n    return true;\n  }\n\n  if (allowMock && isSameDomain(win)) {\n    try {\n      // @ts-ignore\n      if (win.mockclosed) {\n        return true;\n      }\n    } catch (err) {// pass\n    }\n  } // Mobile safari\n\n\n  try {\n    if (!win.parent || !win.top) {\n      return true;\n    }\n  } catch (err) {// pass\n  } // Yes, this actually happens in IE. win === win errors out when the window\n  // is from an iframe, and the iframe was removed from the page.\n\n\n  try {\n    noop(win === win); // eslint-disable-line no-self-compare\n  } catch (err) {\n    return true;\n  } // IE orphaned frame\n\n\n  var iframeIndex = safeIndexOf(iframeWindows, win);\n\n  if (iframeIndex !== -1) {\n    var frame = iframeFrames[iframeIndex];\n\n    if (frame && isFrameWindowClosed(frame)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction cleanIframes() {\n  for (var i = 0; i < iframeWindows.length; i++) {\n    var closed = false;\n\n    try {\n      closed = iframeWindows[i].closed;\n    } catch (err) {// pass\n    }\n\n    if (closed) {\n      iframeFrames.splice(i, 1);\n      iframeWindows.splice(i, 1);\n    }\n  }\n}\n\nexport function linkFrameWindow(frame) {\n  cleanIframes();\n\n  if (frame && frame.contentWindow) {\n    try {\n      iframeWindows.push(frame.contentWindow);\n      iframeFrames.push(frame);\n    } catch (err) {// pass\n    }\n  }\n}\nexport function getUserAgent(win) {\n  win = win || window; // @ts-ignore\n\n  return win.navigator.mockUserAgent || win.navigator.userAgent;\n}\nexport function getFrameByName(win, name) {\n  var winFrames = getFrames(win);\n\n  for (var _i9 = 0; _i9 < winFrames.length; _i9++) {\n    var childFrame = winFrames[_i9];\n\n    try {\n      if (isSameDomain(childFrame) && childFrame.name === name && winFrames.indexOf(childFrame) !== -1) {\n        return childFrame;\n      }\n    } catch (err) {// pass\n    }\n  }\n\n  try {\n    // @ts-ignore\n    if (winFrames.indexOf(win.frames[name]) !== -1) {\n      // @ts-ignore\n      return win.frames[name];\n    }\n  } catch (err) {// pass\n  }\n\n  try {\n    // @ts-ignore\n    if (winFrames.indexOf(win[name]) !== -1) {\n      // @ts-ignore\n      return win[name];\n    }\n  } catch (err) {// pass\n  }\n}\nexport function findChildFrameByName(win, name) {\n  var frame = getFrameByName(win, name);\n\n  if (frame) {\n    return frame;\n  }\n\n  for (var _i11 = 0, _getFrames4 = getFrames(win); _i11 < _getFrames4.length; _i11++) {\n    var childFrame = _getFrames4[_i11];\n    var namedFrame = findChildFrameByName(childFrame, name);\n\n    if (namedFrame) {\n      return namedFrame;\n    }\n  }\n}\nexport function findFrameByName(win, name) {\n  var frame = getFrameByName(win, name);\n\n  if (frame) {\n    return frame;\n  }\n\n  var top = getTop(win) || win;\n  return findChildFrameByName(top, name);\n}\nexport function isParent(win, frame) {\n  var frameParent = getParent(frame);\n\n  if (frameParent) {\n    return frameParent === win;\n  }\n\n  for (var _i13 = 0, _getFrames6 = getFrames(win); _i13 < _getFrames6.length; _i13++) {\n    var childFrame = _getFrames6[_i13];\n\n    if (childFrame === frame) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function isOpener(parent, child) {\n  return parent === getOpener(child);\n}\nexport function getAncestor(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  win = win || window;\n  var opener = getOpener(win);\n\n  if (opener) {\n    return opener;\n  }\n\n  var parent = getParent(win);\n\n  if (parent) {\n    return parent;\n  }\n}\nexport function getAncestors(win) {\n  var results = [];\n  var ancestor = win;\n\n  while (ancestor) {\n    // @ts-ignore\n    ancestor = getAncestor(ancestor);\n\n    if (ancestor) {\n      results.push(ancestor);\n    }\n  }\n\n  return results;\n}\nexport function isAncestor(parent, child) {\n  var actualParent = getAncestor(child);\n\n  if (actualParent) {\n    if (actualParent === parent) {\n      return true;\n    }\n\n    return false;\n  }\n\n  if (child === parent) {\n    return false;\n  }\n\n  if (getTop(child) === child) {\n    return false;\n  }\n\n  for (var _i15 = 0, _getFrames8 = getFrames(parent); _i15 < _getFrames8.length; _i15++) {\n    var frame = _getFrames8[_i15];\n\n    if (frame === child) {\n      return true;\n    }\n  }\n\n  return false;\n}\nexport function isPopup(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return Boolean(getOpener(win));\n}\nexport function isIframe(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return Boolean(getParent(win));\n}\nexport function isFullpage(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  return Boolean(!isIframe(win) && !isPopup(win));\n}\n\nfunction anyMatch(collection1, collection2) {\n  for (var _i17 = 0; _i17 < collection1.length; _i17++) {\n    var item1 = collection1[_i17];\n\n    for (var _i19 = 0; _i19 < collection2.length; _i19++) {\n      var item2 = collection2[_i19];\n\n      if (item1 === item2) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nexport function getDistanceFromTop(win) {\n  if (win === void 0) {\n    win = window;\n  }\n\n  var distance = 0;\n  var parent = win;\n\n  while (parent) {\n    // @ts-ignore - trying to reassing to something that might be window\n    parent = getParent(parent);\n\n    if (parent) {\n      distance += 1;\n    }\n  }\n\n  return distance;\n}\nexport function getNthParent(win, n) {\n  if (n === void 0) {\n    n = 1;\n  }\n\n  var parent = win;\n\n  for (var i = 0; i < n; i++) {\n    if (!parent) {\n      return;\n    } // @ts-ignore - trying to reassing to something that might be window\n\n\n    parent = getParent(parent);\n  }\n\n  return parent;\n}\nexport function getNthParentFromTop(win, n) {\n  if (n === void 0) {\n    n = 1;\n  }\n\n  return getNthParent(win, getDistanceFromTop(win) - n);\n}\nexport function isSameTopWindow(win1, win2) {\n  var top1 = getTop(win1) || win1;\n  var top2 = getTop(win2) || win2;\n\n  try {\n    if (top1 && top2) {\n      if (top1 === top2) {\n        return true;\n      }\n\n      return false;\n    }\n  } catch (err) {// pass\n  }\n\n  var allFrames1 = getAllFramesInWindow(win1);\n  var allFrames2 = getAllFramesInWindow(win2);\n\n  if (anyMatch(allFrames1, allFrames2)) {\n    return true;\n  }\n\n  var opener1 = getOpener(top1);\n  var opener2 = getOpener(top2);\n\n  if (opener1 && anyMatch(getAllFramesInWindow(opener1), allFrames2)) {\n    return false;\n  }\n\n  if (opener2 && anyMatch(getAllFramesInWindow(opener2), allFrames1)) {\n    return false;\n  }\n\n  return false;\n}\nexport function matchDomain(pattern, origin) {\n  if (typeof pattern === 'string') {\n    if (typeof origin === 'string') {\n      return pattern === WILDCARD || origin === pattern;\n    }\n\n    if (isRegex(origin)) {\n      return false;\n    }\n\n    if (Array.isArray(origin)) {\n      return false;\n    }\n  }\n\n  if (isRegex(pattern)) {\n    if (isRegex(origin)) {\n      return pattern.toString() === origin.toString();\n    }\n\n    if (Array.isArray(origin)) {\n      return false;\n    } // @ts-ignore - earlier already shortcutted the string case\n\n\n    return Boolean(origin.match(pattern));\n  }\n\n  if (Array.isArray(pattern)) {\n    if (Array.isArray(origin)) {\n      return JSON.stringify(pattern) === JSON.stringify(origin);\n    }\n\n    if (isRegex(origin)) {\n      return false;\n    }\n\n    return pattern.some(function (subpattern) {\n      return matchDomain(subpattern, origin);\n    });\n  }\n\n  return false;\n}\nexport function stringifyDomainPattern(pattern) {\n  if (Array.isArray(pattern)) {\n    return \"(\" + pattern.join(' | ') + \")\";\n  } else if (isRegex(pattern)) {\n    return \"RegExp(\" + pattern.toString() + \")\";\n  } else {\n    return pattern.toString();\n  }\n}\nexport function getDomainFromUrl(url) {\n  var domain;\n\n  if (url.match(/^(https?|mock|file):\\/\\//)) {\n    domain = url;\n  } else {\n    return getDomain();\n  }\n\n  domain = domain.split('/').slice(0, 3).join('/');\n  return domain;\n}\nexport function onCloseWindow(win, callback, delay, maxtime) {\n  if (delay === void 0) {\n    delay = 1000;\n  }\n\n  if (maxtime === void 0) {\n    maxtime = Infinity;\n  }\n\n  var timeout;\n\n  var check = function check() {\n    if (isWindowClosed(win)) {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n\n      return callback();\n    }\n\n    if (maxtime <= 0) {\n      clearTimeout(timeout);\n    } else {\n      maxtime -= delay;\n      timeout = setTimeout(check, delay);\n    }\n  };\n\n  check();\n  return {\n    cancel: function cancel() {\n      if (timeout) {\n        clearTimeout(timeout);\n      }\n    }\n  };\n} // eslint-disable-next-line complexity\n\nexport function isWindow(obj) {\n  try {\n    if (obj === window) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (Object.prototype.toString.call(obj) === '[object Window]') {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (window.Window && obj instanceof window.Window) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.self === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.parent === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    if (obj && obj.top === obj) {\n      return true;\n    }\n  } catch (err) {\n    if (err && err.message === IE_WIN_ACCESS_ERROR) {\n      return true;\n    }\n  }\n\n  try {\n    // @ts-ignore this equality check is a self compare\n    if (noop(obj === obj) === '__unlikely_value__') {\n      // eslint-disable-line no-self-compare\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if (obj && obj.__cross_domain_utils_window_check__ === '__unlikely_value__') {\n      return false;\n    }\n  } catch (err) {\n    return true;\n  }\n\n  try {\n    if ('postMessage' in obj && 'self' in obj && 'location' in obj) {\n      return true;\n    }\n  } catch (err) {// pass\n  }\n\n  return false;\n}\nexport function isBrowser() {\n  return typeof window !== 'undefined' && typeof window.location !== 'undefined';\n}\nexport function isCurrentDomain(domain) {\n  if (!isBrowser()) {\n    return false;\n  }\n\n  return getDomain() === domain;\n}\nexport function isMockDomain(domain) {\n  return domain.indexOf(PROTOCOL.MOCK) === 0;\n}\nexport function normalizeMockUrl(url) {\n  if (!isMockDomain(getDomainFromUrl(url))) {\n    return url;\n  } // @ts-ignore - global\n\n\n  if (!__TEST__) {\n    throw new Error(\"Mock urls not supported out of test mode\");\n  }\n\n  return url.replace(/^mock:\\/\\/[^/]+/, getActualDomain(window));\n}\nexport function closeWindow(win) {\n  try {\n    win.close();\n  } catch (err) {// pass\n  }\n}\nexport function getFrameForWindow(win) {\n  if (isSameDomain(win)) {\n    // @ts-ignore\n    return assertSameDomain(win).frameElement;\n  } // @ts-ignore not an array type, but is iterable so fine\n\n\n  for (var _i21 = 0, _document$querySelect2 = document.querySelectorAll('iframe'); _i21 < _document$querySelect2.length; _i21++) {\n    var frame = _document$querySelect2[_i21];\n\n    if (frame && frame.contentWindow && frame.contentWindow === win) {\n      return frame;\n    }\n  }\n}","export function safeIndexOf<T>(collection: ReadonlyArray<T>, item: T): number {\n    for (let i = 0; i < collection.length; i++) {\n        try {\n            if (collection[i] === item) {\n                return i;\n            }\n        } catch (err) {\n            // pass\n        }\n    }\n\n    return -1;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function noop(...args: ReadonlyArray<unknown>): void {\n    // pass\n}\n","import { isWindow, isWindowClosed } from 'cross-domain-utils';\n\nimport { hasNativeWeakMap } from './native';\nimport { noop, safeIndexOf } from './util';\n\nexport class CrossDomainSafeWeakMap<\n    K extends Record<string, any>,\n    V extends unknown\n> {\n    name: string;\n    weakmap: WeakMap<K, V> | null | undefined;\n    keys: Array<K>;\n    values: Array<V>;\n\n    constructor() {\n        // eslint-disable-next-line no-bitwise\n        this.name = `__weakmap_${ (Math.random() * 1e9) >>> 0 }__`;\n\n        if (hasNativeWeakMap()) {\n            try {\n                this.weakmap = new WeakMap();\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this.keys = [];\n        this.values = [];\n    }\n\n    _cleanupClosedWindows(): void {\n        const weakmap = this.weakmap;\n        const keys = this.keys;\n\n        for (let i = 0; i < keys.length; i++) {\n            const value = keys[i];\n\n            // @ts-ignore `isWindowClosed` takes window which V is not\n            if (isWindow(value) && isWindowClosed(value)) {\n                if (weakmap) {\n                    try {\n                        weakmap.delete(value);\n                    } catch (err) {\n                        // pass\n                    }\n                }\n\n                keys.splice(i, 1);\n                this.values.splice(i, 1);\n                i -= 1;\n            }\n        }\n    }\n\n    isSafeToReadWrite(key: K): boolean {\n        if (isWindow(key)) {\n            return false;\n        }\n\n        try {\n            noop(key && key.self);\n            noop(key && key[this.name]);\n        } catch (err) {\n            return false;\n        }\n\n        return true;\n    }\n\n    set(key: K, value: V): void {\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.set(key, value);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const name = this.name;\n                const entry = key[name];\n\n                if (entry && entry[0] === key) {\n                    entry[1] = value;\n                } else {\n                    Object.defineProperty(key, name, {\n                        value:   [ key, value ],\n                        writable:true\n                    });\n                }\n\n                return;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const values = this.values;\n        const index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            keys.push(key);\n            values.push(value);\n        } else {\n            values[index] = value;\n        }\n    }\n\n    get(key: K): V | void {\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return weakmap.get(key);\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return entry[1];\n                }\n\n                return;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const index = safeIndexOf(keys, key);\n\n        if (index === -1) {\n            return;\n        }\n\n        return this.values[index];\n    }\n\n    delete(key: K): void {\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                weakmap.delete(key);\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    entry[0] = entry[1] = undefined;\n                }\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const keys = this.keys;\n        const index = safeIndexOf(keys, key);\n\n        if (index !== -1) {\n            keys.splice(index, 1);\n            this.values.splice(index, 1);\n        }\n    }\n\n    has(key: K): boolean {\n        if (!key) {\n            throw new Error(`WeakMap expected key`);\n        }\n\n        const weakmap = this.weakmap;\n\n        if (weakmap) {\n            try {\n                if (weakmap.has(key)) {\n                    return true;\n                }\n            } catch (err) {\n                delete this.weakmap;\n            }\n        }\n\n        if (this.isSafeToReadWrite(key)) {\n            try {\n                const entry = key[this.name];\n\n                if (entry && entry[0] === key) {\n                    return true;\n                }\n\n                return false;\n            } catch (err) {\n                // pass\n            }\n        }\n\n        this._cleanupClosedWindows();\n\n        const index = safeIndexOf(this.keys, key);\n        return index !== -1;\n    }\n\n    getOrSet(key: K, getter: () => V): V {\n        if (this.has(key)) {\n            // @ts-ignore\n            return this.get(key);\n        }\n\n        const value = getter();\n        this.set(key, value);\n        return value;\n    }\n}\n","/* eslint max-lines: 0 */\nimport { ZalgoPromise } from 'zalgo-promise/src';\nimport { WeakMap } from 'cross-domain-safe-weakmap/src';\n\nimport type { CancelableType } from './types';\n\nexport function getFunctionName(fn : Function) : string {\n    // @ts-ignore - cant infer this all from T\n    return fn.name || fn.__name__ || fn.displayName || 'anonymous';\n}\n\nexport function setFunctionName<T extends Function>(fn : T, name : string) : T {\n    try {\n        // @ts-ignore this should be readonly\n        delete fn.name;\n        // @ts-ignore this should be readonly\n        fn.name = name;\n    } catch (err) {\n        // pass\n    }\n\n    // @ts-ignore this should be readonly\n    fn.__name__ = fn.displayName = name;\n    return fn;\n}\n\nexport function base64encode(str : string) : string {\n    if (typeof btoa === 'function') {\n        return btoa(\n            encodeURIComponent(str).replace(/%([0-9A-F]{2})/g, (m, p1) => {\n                return String.fromCharCode(parseInt(p1, 16));\n            })\n        ).replace(/[=]/g, '');\n    }\n\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.from(str, 'utf8').toString('base64').replace(/[=]/g, '');\n    }\n\n    throw new Error(`Can not find window.btoa or Buffer`);\n}\n\nexport function base64decode(str : string) : string {\n    if (typeof atob === 'function') {\n        return decodeURIComponent(\n            Array.prototype.map\n                .call(atob(str), (c) => {\n                    return `%${ `00${ c.charCodeAt(0).toString(16) }`.slice(-2) }`;\n                })\n                .join('')\n        );\n    }\n\n    if (typeof Buffer !== 'undefined') {\n        return Buffer.from(str, 'base64').toString('utf8');\n    }\n\n    throw new Error(`Can not find window.atob or Buffer`);\n}\n\nexport function uniqueID() : string {\n    const chars = '0123456789abcdef';\n    const randomID = 'xxxxxxxxxx'.replace(/./g, () => {\n        return chars.charAt(Math.floor(Math.random() * chars.length));\n    });\n    const timeID = base64encode(new Date().toISOString().slice(11, 19).replace('T', '.'))\n        .replace(/[^a-zA-Z0-9]/g, '')\n        .toLowerCase();\n    return `uid_${ randomID }_${ timeID }`;\n}\n\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nexport function getGlobal() : Record<string, any> {\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n\n    // @ts-ignore - globals\n    if (typeof __GLOBAL__ !== 'undefined') {\n        // @ts-ignore - globals\n        return __GLOBAL__;\n    }\n\n    throw new Error(`No global found`);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nlet objectIDs : any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getObjectID(obj : Record<string, any>) : string {\n    objectIDs = objectIDs || new WeakMap();\n\n    if (obj === null || obj === undefined || (typeof obj !== 'object' && typeof obj !== 'function')) {\n        throw new Error(`Invalid object`);\n    }\n\n    let uid = objectIDs.get(obj);\n\n    if (!uid) {\n        uid = `${ typeof obj }:${ uniqueID() }`;\n        objectIDs.set(obj, uid);\n    }\n\n    return uid;\n}\n\nfunction serializeArgs<T>(args : ReadonlyArray<T>) : string {\n    try {\n        return JSON.stringify(Array.prototype.slice.call(args), (subkey, val) => {\n            if (typeof val === 'function') {\n                return `memoize[${ getObjectID(val) }]`;\n            }\n\n            return val;\n        });\n    } catch (err) {\n        throw new Error(`Arguments not serializable -- can not be used to memoize`);\n    }\n}\n\nexport function getEmptyObject() : Record<string, undefined> {\n    return {};\n}\n\ntype MemoizeOptions = {\n    name ?: string;\n    time ?: number;\n    thisNamespace ?: boolean;\n};\n\nconst getDefaultMemoizeOptions = () : MemoizeOptions => {\n    return {};\n};\n\nexport type Memoized<F> = F & {\n    reset : () => void;\n};\n\nlet memoizeGlobalIndex = 0;\nlet memoizeGlobalIndexValidFrom = 0;\n\nexport function memoize<F extends Function>(method : F, options : MemoizeOptions = getDefaultMemoizeOptions()) : Memoized<F> {\n    const { thisNamespace = false, time: cacheTime } = options;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let simpleCache : any;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let thisCache : any;\n\n    let memoizeIndex = memoizeGlobalIndex;\n    memoizeGlobalIndex += 1;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const memoizedFunction = function memoizedFunction(...args : any) : unknown {\n        if (memoizeIndex < memoizeGlobalIndexValidFrom) {\n            simpleCache = null;\n            thisCache = null;\n            memoizeIndex = memoizeGlobalIndex;\n            memoizeGlobalIndex += 1;\n        }\n\n        let cache;\n\n        if (thisNamespace) {\n            thisCache = thisCache || new WeakMap();\n            // @ts-ignore this is any\n            cache = thisCache.getOrSet(this, getEmptyObject);\n        } else {\n            cache = simpleCache = simpleCache || {};\n        }\n\n        const cacheKey = serializeArgs(args);\n        let cacheResult = cache[cacheKey];\n\n        if (cacheResult && cacheTime && Date.now() - cacheResult.time < cacheTime) {\n            delete cache[cacheKey];\n            cacheResult = null;\n        }\n\n        if (cacheResult) {\n            return cacheResult.value;\n        }\n\n        const time = Date.now();\n        // @ts-ignore\n        const value = method.apply(this, arguments);\n        cache[cacheKey] = {\n            time,\n            value\n        };\n        return value;\n    };\n\n    memoizedFunction.reset = () => {\n        simpleCache = null;\n        thisCache = null;\n    };\n\n    // @ts-ignore\n    const result : F = memoizedFunction;\n    // @ts-ignore\n    return setFunctionName(result, `${ options.name || getFunctionName(method) }::memoized`);\n}\n\nmemoize.clear = () => {\n    memoizeGlobalIndexValidFrom = memoizeGlobalIndex;\n};\n\nexport function promiseIdentity<T extends unknown>(item : ZalgoPromise<T> | T) : ZalgoPromise<T> {\n    return ZalgoPromise.resolve(item);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function memoizePromise<R>(method : (...args : ReadonlyArray<any>) => ZalgoPromise<R>) : (...args : ReadonlyArray<any>) => ZalgoPromise<R> {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let cache : Record<string, any> = {};\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function memoizedPromiseFunction(...args : ReadonlyArray<any>) : ZalgoPromise<R> {\n        const key : string = serializeArgs(args);\n\n        if (cache.hasOwnProperty(key)) {\n            return cache[key];\n        }\n\n        cache[key] = ZalgoPromise.try(() =>\n            // @ts-ignore\n            method.apply(this, arguments)).finally(() => {\n            delete cache[key];\n        });\n        return cache[key];\n    }\n\n    memoizedPromiseFunction.reset = () => {\n        cache = {};\n    };\n\n    return setFunctionName(memoizedPromiseFunction, `${ getFunctionName(method) }::promiseMemoized`);\n}\n\ntype PromisifyOptions = {\n    name ?: string;\n};\n\nconst getDefaultPromisifyOptions = () : PromisifyOptions => {\n    return {};\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function promisify<R>(method : (...args : ReadonlyArray<any>) => R, options : PromisifyOptions = getDefaultPromisifyOptions()) : (...args : ReadonlyArray<any>) => ZalgoPromise<R> {\n    function promisifiedFunction() : ZalgoPromise<R> {\n        // @ts-ignore\n        return ZalgoPromise.try(method, this, arguments);\n    }\n\n    if (options.name) {\n        promisifiedFunction.displayName = `${ options.name }:promisified`;\n    }\n\n    return setFunctionName(promisifiedFunction, `${ getFunctionName(method) }::promisified`);\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any, no-shadow\nexport function inlineMemoize<R>(method : (...args : ReadonlyArray<any>) => R, logic : (...args : ReadonlyArray<any>) => R, args : ReadonlyArray<any> = []) : R {\n    // @ts-ignore method.__inline_memoize_cache__ not in type def\n    const cache : Record<string, R> = (method.__inline_memoize_cache__ = method.__inline_memoize_cache__ || {});\n    const key = serializeArgs(args);\n\n    if (cache.hasOwnProperty(key)) {\n        return cache[key];\n    }\n\n    const result = (cache[key] = logic(...args));\n    return result;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport function noop(...args : ReadonlyArray<unknown>) : void {\n    // pass\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function once(method : (...args : Array<any>) => any) : (...args : Array<any>) => any {\n    let called = false;\n\n    const onceFunction = function () : unknown {\n        if (!called) {\n            called = true;\n            // @ts-ignore\n            return method.apply(this, arguments);\n        }\n    };\n\n    return setFunctionName(onceFunction, `${ getFunctionName(method) }::once`);\n}\n\nexport function hashStr(str : string) : number {\n    let hash = 0;\n\n    for (let i = 0; i < str.length; i++) {\n        hash += str[i].charCodeAt(0) * Math.pow((i % 10) + 1, 5);\n    }\n\n    return Math.floor(Math.pow(Math.sqrt(hash), 5));\n}\n\nexport function strHashStr(str : string) : string {\n    let hash = '';\n\n    for (let i = 0; i < str.length; i++) {\n        let total = str[i].charCodeAt(0) * i;\n\n        if (str[i + 1]) {\n            total += str[i + 1].charCodeAt(0) * (i - 1);\n        }\n\n        hash += String.fromCharCode(97 + (Math.abs(total) % 26));\n    }\n\n    return hash;\n}\n\nexport function match(str : string, pattern : RegExp) : string | null | undefined {\n    const regmatch = str.match(pattern);\n\n    if (regmatch) {\n        return regmatch[1];\n    }\n}\n\nexport function awaitKey<T extends unknown>(obj : Record<string, T>, key : string) : ZalgoPromise<T> {\n    return new ZalgoPromise((resolve : Function) => {\n        let value = obj[key];\n\n        if (value) {\n            return resolve(value);\n        }\n\n        delete obj[key];\n        Object.defineProperty(obj, key, {\n            configurable: true,\n\n            set(item) {\n                value = item;\n\n                if (value) {\n                    resolve(value);\n                }\n            },\n\n            get() : T {\n                return value;\n            }\n        });\n    });\n}\n\nexport function stringifyError(err : unknown, level = 1) : string {\n    if (level >= 3) {\n        return 'stringifyError stack overflow';\n    }\n\n    try {\n        if (!err) {\n            return `<unknown error: ${ Object.prototype.toString.call(err) }>`;\n        }\n\n        if (typeof err === 'string') {\n            return err;\n        }\n\n        if (err instanceof Error) {\n            const stack = err && err.stack;\n            const message = err && err.message;\n\n            if (stack && message) {\n                if (stack.indexOf(message) !== -1) {\n                    return stack;\n                } else {\n                    return `${ message }\\n${ stack }`;\n                }\n            } else if (stack) {\n                return stack;\n            } else if (message) {\n                return message;\n            }\n        }\n\n        // @ts-ignore\n        if (err && err.toString && typeof err.toString === 'function') {\n            // @ts-ignore\n            return err.toString();\n        }\n\n        return Object.prototype.toString.call(err);\n    } catch (newErr) {\n        return `Error while stringifying error: ${ stringifyError(newErr, level + 1) }`;\n    }\n}\n\nexport function stringifyErrorMessage(err : Error) : string {\n    const defaultMessage = `<unknown error: ${ Object.prototype.toString.call(err) }>`;\n\n    if (!err) {\n        return defaultMessage;\n    }\n\n    if (err instanceof Error) {\n        return err.message || defaultMessage;\n    }\n\n    // @ts-ignore\n    if (typeof err.message === 'string') {\n        // @ts-ignore\n        return err.message || defaultMessage;\n    }\n\n    return defaultMessage;\n}\n\nexport function stringify(item : unknown) : string {\n    if (typeof item === 'string') {\n        return item;\n    }\n\n    // @ts-ignore\n    if (item && item.toString && typeof item.toString === 'function') {\n        // @ts-ignore\n        return item.toString();\n    }\n\n    return Object.prototype.toString.call(item);\n}\n\nexport function domainMatches(hostname : string, domain : string) : boolean {\n    hostname = hostname.split('://')[1];\n    const index = hostname.indexOf(domain);\n    return index !== -1 && hostname.slice(index) === domain;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function patchMethod(obj : Record<string, any>, name : string, handler : (...args : Array<any>) => any) : void {\n    const original = obj[name];\n\n    obj[name] = function patchedMethod() : unknown {\n        return handler({\n            context:     this,\n            args:        Array.prototype.slice.call(arguments),\n            original,\n            // @ts-ignore\n            callOriginal:() => original.apply(this, arguments)\n        });\n    };\n}\n\nexport function extend<T>(obj : Record<string, T>, source : Record<string, T>) : Record<string, T> {\n    if (!source) {\n        return obj;\n    }\n\n    if (Object.assign) {\n        return Object.assign(obj, source);\n    }\n\n    for (const key in source) {\n        if (source.hasOwnProperty(key)) {\n            // @ts-ignore\n            obj[key] = source[key];\n        }\n    }\n\n    return obj;\n}\n\nexport function values<T>(obj : Record<string, T>) : ReadonlyArray<T> {\n    if (Object.values) {\n        return Object.values(obj);\n    }\n\n    const result : Array<T> = [];\n\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            result.push(obj[key]);\n        }\n    }\n\n    return result;\n}\n\nexport const memoizedValues : <T>(arg0 : Record<string, T>) => ReadonlyArray<T> = memoize(values);\n\nexport function perc(pixels : number, percentage : number) : number {\n    return Math.round((pixels * percentage) / 100);\n}\n\nexport function min(...args : ReadonlyArray<number>) : number {\n    return Math.min(...args);\n}\n\nexport function max(...args : ReadonlyArray<number>) : number {\n    return Math.max(...args);\n}\n\nexport function roundUp(num : number, nearest : number) : number {\n    const remainder = num % nearest;\n    return remainder ? num - remainder + nearest : num;\n}\n\nexport function regexMap<T>(str : string, regexp : RegExp, handler : () => T) : ReadonlyArray<T> {\n    const results : T[] = [];\n    // @ts-ignore\n    str.replace(regexp, function regexMapMatcher(item : string) {\n        // @ts-ignore\n        results.push(handler ? handler.apply(null, arguments) : item);\n    });\n    return results;\n}\n\nexport function svgToBase64(svg : string) : string {\n    return `data:image/svg+xml;base64,${ base64encode(svg) }`;\n}\n\nexport function objFilter<T, R>(\n    obj : Record<string, T>,\n    filter : (arg0 : T, arg1 : string | null | undefined) => unknown = Boolean\n) : Record<string, R> {\n    const result : Record<string, R> = {};\n\n    for (const key in obj) {\n        if (!obj.hasOwnProperty(key) || !filter(obj[key], key)) {\n            continue;\n        }\n\n        // @ts-ignore expect R but gets T\n        result[key] = obj[key];\n    }\n\n    return result;\n}\n\nexport function identity<T>(item : T) : T {\n    return item;\n}\n\nexport function regexTokenize(text : string, regexp : RegExp) : ReadonlyArray<string> {\n    const result : string[] = [];\n    text.replace(regexp, (token) => {\n        result.push(token);\n        return '';\n    });\n    return result;\n}\n\nexport function promiseDebounce<T>(method : () => ZalgoPromise<T> | T, delay = 50) : () => ZalgoPromise<T> {\n    let promise : ZalgoPromise<T> | null;\n    let timeout : NodeJS.Timeout | null;\n\n    const promiseDebounced = function () : ZalgoPromise<T> {\n        if (timeout) {\n            clearTimeout(timeout);\n        }\n\n        const localPromise = (promise = promise || new ZalgoPromise());\n        timeout = setTimeout(() => {\n            promise = null;\n            timeout = null;\n            ZalgoPromise.try(method).then(\n                (result : T) => {\n                    localPromise.resolve(result);\n                },\n                (err : unknown) => {\n                    localPromise.reject(err);\n                }\n            );\n        }, delay);\n        return localPromise;\n    };\n\n    return setFunctionName(promiseDebounced, `${ getFunctionName(method) }::promiseDebounced`);\n}\n\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nexport function safeInterval(method : (...args : Array<any>) => any, time : number) : {\n    cancel : () => void;\n} {\n    let timeout : NodeJS.Timeout;\n\n    function loop() {\n        timeout = setTimeout(() => {\n            method();\n            loop();\n        }, time);\n    }\n\n    loop();\n    return {\n        cancel() {\n            clearTimeout(timeout);\n        }\n    };\n}\n\nexport function isInteger(str : string) : boolean {\n    return Boolean(str.match(/^[0-9]+$/));\n}\n\nexport function isFloat(str : string) : boolean {\n    return Boolean(str.match(/^[0-9]+\\.[0-9]+$/));\n}\n\nexport function serializePrimitive(value : string | number | boolean) : string {\n    return value.toString();\n}\n\nexport function deserializePrimitive(value : string) : string | number | boolean {\n    if (value === 'true') {\n        return true;\n    } else if (value === 'false') {\n        return false;\n    } else if (isInteger(value)) {\n        return parseInt(value, 10);\n    } else if (isFloat(value)) {\n        return parseFloat(value);\n    } else {\n        return value;\n    }\n}\n\nexport function dotify(\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n    obj : Record<string, any>,\n    prefix = '',\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n    newobj : Record<string, any> = {}\n) : Record<string, string> {\n    prefix = prefix ? `${ prefix }.` : prefix;\n\n    for (const key in obj) {\n        if (!obj.hasOwnProperty(key) || obj[key] === undefined || obj[key] === null || typeof obj[key] === 'function') {\n            continue;\n        } else if (\n            obj[key] &&\n            Array.isArray(obj[key]) &&\n            obj[key].length &&\n            // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n            obj[key].every((val : any) => typeof val !== 'object')\n        ) {\n            newobj[`${ prefix }${ key }[]`] = obj[key].join(',');\n        } else if (obj[key] && typeof obj[key] === 'object') {\n            newobj = dotify(obj[key], `${ prefix }${ key }`, newobj);\n        } else {\n            newobj[`${ prefix }${ key }`] = serializePrimitive(obj[key]);\n        }\n    }\n\n    return newobj;\n}\n\n// eslint-disable-next-line  @typescript-eslint/no-explicit-any\nexport function undotify(obj : Record<string, string>) : Record<string, any> {\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n    const result : Record<string, any> = {};\n\n    for (let key in obj) {\n        if (!obj.hasOwnProperty(key) || typeof obj[key] !== 'string') {\n            continue;\n        }\n\n        // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n        let value : any = obj[key];\n\n        if (key.match(/^.+\\[\\]$/)) {\n            key = key.slice(0, -2);\n            value = value.split(',').map(deserializePrimitive);\n        } else {\n            value = deserializePrimitive(value);\n        }\n\n        let keyResult = result;\n        const parts = key.split('.');\n\n        for (let i = 0; i < parts.length; i++) {\n            const part = parts[i];\n            const isLast = i + 1 === parts.length;\n            const isIndex = !isLast && isInteger(parts[i + 1]);\n\n            if (part === 'constructor' || part === 'prototype' || part === '__proto__') {\n                throw new Error(`Disallowed key: ${ part }`);\n            }\n\n            if (isLast) {\n                keyResult[part] = value;\n            } else {\n                keyResult = keyResult[part] = keyResult[part] || (isIndex ? [] : {});\n            }\n        }\n    }\n\n    return result;\n}\n\nexport type EventEmitterType = {\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n    on : (eventName : string, handler : (...args : Array<any>) => any) => CancelableType;\n    // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n    once : (eventName : string, handler : (...args : Array<any>) => any) => CancelableType;\n    trigger : (eventName : string, ...args : ReadonlyArray<unknown>) => ZalgoPromise<void>;\n    triggerOnce : (eventName : string, ...args : ReadonlyArray<unknown>) => ZalgoPromise<void>;\n    reset : () => void;\n};\n\nexport function eventEmitter() : EventEmitterType {\n    const triggered = {};\n    let handlers = {};\n    const emitter = {\n        // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n        on(eventName : string, handler : (...args : Array<any>) => any) : CancelableType {\n            // @ts-ignore\n            const handlerList = (handlers[eventName] = handlers[eventName] || []);\n            handlerList.push(handler);\n            let cancelled = false;\n            return {\n                cancel() {\n                    if (!cancelled) {\n                        cancelled = true;\n                        handlerList.splice(handlerList.indexOf(handler), 1);\n                    }\n                }\n            };\n        },\n\n        // eslint-disable-next-line  @typescript-eslint/no-explicit-any\n        once(eventName : string, handler : (...args : Array<any>) => any) : CancelableType {\n            const listener = emitter.on(eventName, () => {\n                listener.cancel();\n                handler();\n            });\n            return listener;\n        },\n\n        trigger(eventName : string, ...args : ReadonlyArray<unknown>) : ZalgoPromise<void> {\n            // @ts-ignore\n            const handlerList = handlers[eventName];\n            const promises = [];\n\n            if (handlerList) {\n                for (const handler of handlerList) {\n                    promises.push(ZalgoPromise.try(() => handler(...args)));\n                }\n            }\n\n            return ZalgoPromise.all(promises).then(noop);\n        },\n\n        triggerOnce(eventName : string, ...args : ReadonlyArray<unknown>) : ZalgoPromise<void> {\n            // @ts-ignore\n            if (triggered[eventName]) {\n                return ZalgoPromise.resolve();\n            }\n\n            // @ts-ignore\n            triggered[eventName] = true;\n            return emitter.trigger(eventName, ...args);\n        },\n\n        reset() {\n            handlers = {};\n        }\n    };\n    return emitter;\n}\n\nexport function camelToDasherize(string : string) : string {\n    return string.replace(/([A-Z])/g, (g) => {\n        return `-${ g.toLowerCase() }`;\n    });\n}\n\nexport function dasherizeToCamel(string : string) : string {\n    return string.replace(/-([a-z])/g, (g) => {\n        return g[1].toUpperCase();\n    });\n}\n\nexport function capitalizeFirstLetter(string : string) : string {\n    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function get(item : Record<string, any>, path : string, def : unknown) : unknown {\n    if (!path) {\n        return def;\n    }\n\n    const pathParts = path.split('.');\n\n    // Loop through each section of our key path\n    for (let i = 0; i < pathParts.length; i++) {\n        // If we have an object, we can get the key\n        if (typeof item === 'object' && item !== null) {\n            item = item[pathParts[i]]; // Otherwise, we should return the default (undefined if not provided)\n        } else {\n            return def;\n        }\n    }\n\n    // If our final result is undefined, we should return the default\n    return item === undefined ? def : item;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function safeTimeout(method : (...args : Array<any>) => any, time : number) : void {\n    const interval = safeInterval(() => {\n        time -= 100;\n\n        if (time <= 0) {\n            interval.cancel();\n            method();\n        }\n    }, 100);\n}\n\nexport function defineLazyProp<T>(\n    obj : Record<string, T> | ReadonlyArray<unknown>,\n    key : string | number,\n    getter : () => T\n) : void {\n    if (Array.isArray(obj)) {\n        if (typeof key !== 'number') {\n            throw new TypeError(`Array key must be number`);\n        }\n    } else if (typeof obj === 'object' && obj !== null) {\n        if (typeof key !== 'string') {\n            throw new TypeError(`Object key must be string`);\n        }\n    }\n\n    Object.defineProperty(obj, key, {\n        configurable:true,\n        enumerable:  true,\n        get:         () => {\n            // @ts-ignore\n            delete obj[key];\n            const value = getter();\n            // @ts-ignore\n            obj[key] = value;\n            return value;\n        },\n        set: (value : T) => {\n            // @ts-ignore\n            delete obj[key];\n            // @ts-ignore\n            obj[key] = value;\n        }\n    });\n}\n\nexport function arrayFrom<T>(item : Iterable<T>) : ReadonlyArray<T> {\n    return Array.prototype.slice.call(item);\n}\n\nexport function isObject(item : unknown) : boolean {\n    return typeof item === 'object' && item !== null;\n}\n\nexport function isObjectObject(obj : unknown) : boolean {\n    return isObject(obj) && Object.prototype.toString.call(obj) === '[object Object]';\n}\n\nexport function isPlainObject(obj : unknown) : boolean {\n    if (!isObjectObject(obj)) {\n        return false;\n    }\n\n    // @ts-ignore\n    const constructor = obj.constructor;\n\n    if (typeof constructor !== 'function') {\n        return false;\n    }\n\n    const prototype = constructor.prototype;\n\n    if (!isObjectObject(prototype)) {\n        return false;\n    }\n\n    if (!prototype.hasOwnProperty('isPrototypeOf')) {\n        return false;\n    }\n\n    return true;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function replaceObject<T extends ReadonlyArray<unknown> | Record<string, any>>(\n    item : T,\n    replacer : (arg0 : unknown, arg1 : string | number, arg2 : string) => unknown,\n    fullKey = ''\n) : T {\n    if (Array.isArray(item)) {\n        const length = item.length;\n        const result : Array<unknown> = [];\n\n        for (let i = 0; i < length; i++) {\n            defineLazyProp(result, i, () => {\n                const itemKey = fullKey ? `${ fullKey }.${ i }` : `${ i }`;\n                const el = item[i];\n                let child = replacer(el, i, itemKey);\n\n                if (isPlainObject(child) || Array.isArray(child)) {\n                    // @ts-ignore\n                    child = replaceObject(child, replacer, itemKey);\n                }\n\n                return child;\n            });\n        }\n\n        // @ts-ignore\n        return result;\n    } else if (isPlainObject(item)) {\n        const result = {};\n\n        for (const key in item) {\n            if (!item.hasOwnProperty(key)) {\n                continue;\n            }\n\n            defineLazyProp(result, key, () => {\n                const itemKey = fullKey ? `${ fullKey }.${ key }` : `${ key }`;\n                const el = item[key];\n                let child = replacer(el, key, itemKey);\n\n                if (isPlainObject(child) || Array.isArray(child)) {\n                    // @ts-ignore\n                    child = replaceObject(child, replacer, itemKey);\n                }\n\n                return child;\n            });\n        }\n\n        // @ts-ignore\n        return result;\n    } else {\n        throw new Error(`Pass an object or array`);\n    }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function copyProp(source : Record<string, any>, target : Record<string, any>, name : string, def : unknown) : void {\n    if (source.hasOwnProperty(name)) {\n        const descriptor = Object.getOwnPropertyDescriptor(source, name);\n        // @ts-ignore\n        Object.defineProperty(target, name, descriptor);\n    } else {\n        target[name] = def;\n    }\n}\n\ntype RegexResultType = {\n    text : string;\n    groups : ReadonlyArray<string>;\n    start : number;\n    end : number;\n    length : number;\n    replace : (text : string) => string;\n};\n\nexport function regex(pattern : string | RegExp, string : string, start = 0) : RegexResultType | null | undefined {\n    if (typeof pattern === 'string') {\n        // eslint-disable-next-line security/detect-non-literal-regexp\n        pattern = new RegExp(pattern);\n    }\n\n    const result = string.slice(start).match(pattern);\n\n    if (!result) {\n        return;\n    }\n\n    const index : number = result.index as number;\n    const regmatch = result[0];\n    return {\n        text:  regmatch,\n        groups:result.slice(1),\n        start: start + index,\n        end:   start + index + regmatch.length,\n        length:regmatch.length,\n\n        replace(text : string) : string {\n            if (!regmatch) {\n                return '';\n            }\n\n            return `${ regmatch.slice(0, start + index) }${ text }${ regmatch.slice(index + regmatch.length) }`;\n        }\n    };\n}\n\nexport function regexAll(pattern : string | RegExp, string : string) : ReadonlyArray<RegexResultType> {\n    const matches = [];\n    let start = 0;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        const regmatch = regex(pattern, string, start);\n\n        if (!regmatch) {\n            break;\n        }\n\n        matches.push(regmatch);\n        // @ts-ignore\n        start = match.end;\n    }\n\n    return matches;\n}\n\nexport function isDefined(value : unknown | null | undefined) : boolean {\n    return value !== null && value !== undefined;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function cycle(method : (...args : Array<any>) => any) : ZalgoPromise<void> {\n    // @ts-ignore - not even sure what to do with this\n    return ZalgoPromise.try(method).then(() => cycle(method));\n}\n\nexport function debounce<T>(\n    method : (...args : ReadonlyArray<unknown>) => T,\n    time = 100\n) : (...args : ReadonlyArray<unknown>) => void {\n    let timeout : NodeJS.Timeout;\n\n    const debounceWrapper = function () {\n        clearTimeout(timeout);\n        timeout = setTimeout(() => {\n            // @ts-ignore\n            return method.apply(this, arguments);\n        }, time);\n    };\n\n    return setFunctionName(debounceWrapper, `${ getFunctionName(method) }::debounced`);\n}\n\nexport function isRegex(item : unknown) : boolean {\n    return Object.prototype.toString.call(item) === '[object RegExp]';\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype FunctionProxy<T extends (...args : Array<any>) => any> = (method : T) => T;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const weakMapMemoize : FunctionProxy<any> = <R extends unknown>(method : (arg : any) => R) : ((...args : ReadonlyArray<any>) => R) => {\n    const weakmap = new WeakMap();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function weakmapMemoized(arg : any) : R {\n        // @ts-ignore\n        return weakmap.getOrSet(arg, () => method.call(this, arg));\n    };\n};\n\ntype FunctionPromiseProxy<R extends unknown, T extends (...args : ReadonlyArray<unknown>) => ZalgoPromise<R>> = (\n    arg0 : T\n) => T;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const weakMapMemoizePromise : FunctionPromiseProxy<any, any> = <R extends unknown>(method : (arg : any) => ZalgoPromise<R>) : ((...args : ReadonlyArray<any>) => ZalgoPromise<R>) => {\n    const weakmap = new WeakMap();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return function weakmapMemoizedPromise(arg : any) : ZalgoPromise<R> {\n        // @ts-ignore\n        return weakmap.getOrSet(arg, () =>\n            // @ts-ignore\n            method.call(this, arg).finally(() => {\n                weakmap.delete(arg);\n            }));\n    };\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getOrSet<T extends unknown>(obj : Record<string, any>, key : string, getter : () => T) : T {\n    if (obj.hasOwnProperty(key)) {\n        return obj[key];\n    }\n\n    const val = getter();\n    obj[key] = val;\n    return val;\n}\n\nexport type CleanupType = {\n    set : <T extends unknown>(arg0 : string, arg1 : T) => T;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    register : (arg0 : (...args : Array<any>) => any) => void;\n    all : (err ?: unknown) => ZalgoPromise<void>;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function cleanup(obj : Record<string, any>) : CleanupType {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const tasks : Array<any> = [];\n    let cleaned = false;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let cleanErr : any;\n    const cleaner = {\n        set<T extends unknown>(name : string, item : T) : T {\n            if (!cleaned) {\n                obj[name] = item;\n                cleaner.register(() => {\n                    delete obj[name];\n                });\n            }\n\n            return item;\n        },\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        register(method : (...args : Array<any>) => any) {\n            if (cleaned) {\n                method(cleanErr);\n            } else {\n                tasks.push(once(() => method(cleanErr)));\n            }\n        },\n\n        all(err ?: unknown) : ZalgoPromise<void> {\n            cleanErr = err;\n            const results = [];\n            cleaned = true;\n\n            while (tasks.length) {\n                const task = tasks.shift();\n                results.push(task());\n            }\n\n            return ZalgoPromise.all(results).then(noop);\n        }\n    };\n    return cleaner;\n}\n\nexport function tryCatch<T>(fn : () => T) :\n    | {\n          result : T;\n          error : void;\n      }\n    | {\n          result : T | undefined;\n          error : unknown;\n      } {\n    let result;\n    let error;\n\n    try {\n        result = fn();\n    } catch (err) {\n        error = err;\n    }\n\n    return {\n        result,\n        error\n    };\n}\n\nexport function removeFromArray<X, T extends Array<X>>(arr : T, item : X) : void {\n    const index = arr.indexOf(item);\n\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n}\n\nexport function assertExists<T>(name : string, thing : void | null | T) : T {\n    if (thing === null || typeof thing === 'undefined') {\n        throw new Error(`Expected ${ name } to be present`);\n    }\n\n    return thing;\n}\n\nexport function unique(arr : ReadonlyArray<string>) : ReadonlyArray<string> {\n    const result : Record<string, boolean> = {};\n\n    for (const item of arr) {\n        result[item] = true;\n    }\n\n    return Object.keys(result);\n}\n\nexport const constHas = <X extends string | boolean | number, T extends Record<string, X>>(\n    constant : T,\n    value : X\n) : boolean => {\n    return memoizedValues(constant).indexOf(value) !== -1;\n};\n\nexport function dedupeErrors<T>(handler : (arg0 : unknown) => T) : (arg0 : unknown) => T | void {\n    const seenErrors : unknown[] = [];\n    const seenStringifiedErrors : Record<string, unknown> = {};\n    return (err) => {\n        if (seenErrors.indexOf(err) !== -1) {\n            return;\n        }\n\n        seenErrors.push(err);\n        const stringifiedError = stringifyError(err);\n\n        if (seenStringifiedErrors[stringifiedError]) {\n            return;\n        }\n\n        seenStringifiedErrors[stringifiedError] = true;\n        return handler(err);\n    };\n}\n\nexport class ExtendableError extends Error {\n    constructor(message : string) {\n        super(message);\n        // eslint-disable-next-line unicorn/custom-error-definition\n        this.name = this.constructor.name;\n\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, this.constructor);\n        } else {\n            this.stack = new Error(message).stack;\n        }\n    }\n}\n","export function hasNativeWeakMap(): boolean {\n    if (typeof WeakMap === 'undefined') {\n        return false;\n    }\n\n    if (typeof Object.freeze === 'undefined') {\n        return false;\n    }\n\n    try {\n        const testWeakMap = new WeakMap();\n        const testKey = {};\n        const testValue = '__testvalue__';\n        Object.freeze(testKey);\n        testWeakMap.set(testKey, testValue);\n\n        if (testWeakMap.get(testKey) === testValue) {\n            return true;\n        }\n\n        return false;\n    } catch (err) {\n        return false;\n    }\n}\n","import { uniqueID, base64encode } from 'belter/src/util';\n\n\nexport function getUniqueID() : string {\n    return uniqueID();\n}\n\nexport function stringToBase64(str : string) : string {\n    return base64encode(str);\n}\n"],"sourceRoot":""}